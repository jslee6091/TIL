### 임베디드 소프트웨어 종류

- 아두이노
  - 운영체제 없이 동작하는 보드
  - 운영체제가 없으므로 미들웨어도 없다.
  - 그러므로 목적을 실현할 절차를 모두 만들어야 한다.
- 라즈베리파이
  - 범용 운영체제인 리눅스를 기반으로 동작
  - 운영체제가 있으므로 시스템 내부에 미들웨어도 존재한다.



### 개발 흐름

- PC에서 GCC 컴파일러를 이용하여 소스코드를 빌드하고 실행할 수 있지만 임베디드 시스템에서는 실행 불가

  - PC와 임베디드 시스템의 CPU가 서로 다르기 때문

- 임베디드 시스템 전용 개발 환경인 크로스 개발 환경을 구축해야 함

- 빌드 과정

  - 프리프로세스 처리

    - 컴파일의 전단계로 C언어의 매크로를 전개하여 #include 또는 #ifdef 등 디렉티브를 처리함

    - ```
      avr-gcc -Os -Wall -mmcu=atmega328p -E main.c > preprocess.c
      ```

    - preprocess.c 라는 파일이 출력됨

  - 컴파일 처리

    - 프리프로세스 처리에 의해 전개된 소스코드를 어셈블러 코드로 변환

    - ```
      avr-gcc -Os -Wall -mmcu=atmega328p -S preprocess.c
      ```

    - preprocess.s 파일이 출력됨

  - 어셈블 처리

    - 어셈블리어로 변환한 코드를 OBJ 형식으로 변환

    - ```
      avr-as -mmcu=atmega328p -o main.o preprocess.s
      ```

    - main.o 파일이 출력됨(바이너리 파일이므로 텍스트 에디터로 볼 수 없음)

  - 링크 처리

    - 의존하고 있는 라이브러리 등을 합하여 실행 할 수 있는 파일로 변환

    - ```
      avr-ld -o test.elf main.o crtatmega328p.o 파일위치 libc.a 파일위치 libatmega328p.a 파일위치 libgcc.a 파일위치
      ```

    - 각 파일은 arduino IDE 파일 폴더 내에서 찾는다.

    - test.elf 파일 출력

  - HEX 파일 변환

    - 임베디드 시스템의 ROM에 기록하기 위해 HEX파일로 변환

    - ```
      avr-objcopy -I elf32-avr -O ihex test.elf test.hex
      ```



### 어셈블리어로부터 알 수 있는 것

- 어셈블리어 전체 보기 명령어

  - ```
    avr-gcc -O0 -Wall -mmcu=atmega328p main2.c -o main2.elf
    ```

  - ```
    avr-objdump -S main2.elf > main2.s
    ```

  - 최적화 처리를 무효로 하여(-O0) 명령어를 실행하면 어셈블리 전체 코드(수백 줄)를 얻을 수 있다.

- 스타트업 루틴

  - 하드웨어와 소프트웨어 동작을 위한 초기 설정
  - 함수 호출에 이용되는 스택과 전역 변수 초기 설정 등 메모리 초기 설정 실시

- 메모리 맵

  - 메모리 각 영역의 역할을 나타낸 것
  - 코드 영역과 데이터 영역으로 나뉨
    - 코드 영역 : 읽기 전용의 영역으로 ROM 공간을 가리킴
    - 데이터 영역 : 읽고 쓰기가 가능한 영역으로 RAM 공간을 가리킴
  - 영역은 **섹션**이라고 불린다.

- 스택

  - 함수 호출 시 이용되는 메모리 영역
  - LIFO(Last In First Out)
  - 스택 포인터를 통해 돌아갈 주소, 파라미터 들을 스택에 넣는다.
  - 인터럽트 발생 시 발생 이전에 처리하던 주소를 돌아갈 주소로 스택에 등록함



### 테스트 환경

1. ICE
   - In-Circuit Emulator(ICE)는 임베디드 시스템의 CPU를 대신해서 동작하는 기기
   - JTAG ICE, Full ICE 가 있음
   - JTAG ICE : JTAG 인터페이스로 임베디드 시스템의 CPU가 갖는 디버깅 기능 이용
   - Full ICE : 임베디드 시스템의 CPU를 Emulation 한다.
   - 최근의 경향은 OCD(On-Chip-Debugger)가 점차 표준 탑재 되어 가므로 JTAG ICE가 주류임
2. 시리얼
   - 시리얼(직렬) 포트를 이용한 테스트
   - 테스트, 디버깅에 이용하는 기능은 없으므로 시리얼 포트에 출력하는 기능을 구현하여 모니터링 실시
3. 파형 관측
   - 로직 분석기, 오실로스코프 등 계측기를 사용하여 테스트 및 디버그를 실시함





### C언어

> 임베디드 시스템 프로그래밍에서 유의 사항

1. 최적화 옵션
   - 임베디드 시스템은 메모리 용량, 처리 시간 등에 제약이 있으므로 컴파일러의 최적화 옵션을 이용하여 프로그램의 구조를 최적화 함
2. volatile 선언
   - 주기적으로 하드웨어를 감시하는 폴링(polling)을 할 때 컴파일러의 최적화 옵션을 사용하면 의도하지 않은 상황으로 전개될 가능성이 있다.
   - 예를 들면 for문 안의 if문이 있는 구조에서 최적화 옵션으로 인해 for문이 없어지는 경우가 있다.
   - 이러한 상황을 막기 위해 volatile 선언을 하여 최적화를 하지 않도록 할 수 있다.
3. unsigned/signed
   - +인지 -인지에 따라 최상위 비트가 의미하는 바가 달라지는데 하드웨어를 제어할 때는 의도하지 않은 값이 되는 상황을 방지하기 위해 unsigned 타입을 권장한다.
4. pragma
   - pragma를 이용하면 하드웨어나 메모리 주소를 지정하여 데이터나 코드를 배치할 수 있다.
   - 컴파일러에게 지시하기 위한 옵션이므로 컴파일러의 사양을 확인해야 한다.
5. Pointer와 배열
   - 배열보다는 Pointer를 사용하는 것이 메모리 용량, 처리 속도 등 하드웨어의 성능에 대한 제약속에서 최적화를 더 많이 이룰 수 있다.
6. Interrupt Handler
   - 인터럽트 처리가 길면 일반 처리에 영향을 끼치므로 간단하고 최소한의 처리만을 작성한다.
   - avr에서 ISR() 매크로 함수를 이용하여 인터럽트 벡터로 등록할 수 있는데 이를 통해 인터럽트 발생 시 CPU가 자동으로 전환해줌